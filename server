NORTH = 0
EAST = 1
SOUTH = 2
WEST = 3


turtles = {}
args = {...}


function findTurtle(id)
   for i,v in pairs(turtles) do
      if v.id == id then
	 return(v)
      end
   end
   return(nil)
end


function login(sid)
   rednet.send(sid, "Welcome to the group.")
   print(tostring(sid) .. " Has logged in!")
   local turtle = {id=sid, status="new", work=nil}
   if not findTurtle(sid) then
      table.insert(turtles, turtle)
   end
   return(turtle)
end

function getTurtleByID(rednetID)
   assert(type(rednetID) == "number")
   for i,v in pairs(turtles) do
      if(v.id == rednetID) then
	 return(v)
      end
   end
end

function getTurtleByStatus(status)
   assert(type(status) == "string")
   for i, v in pairs(turtles) do
      if(v.status == status) then
	 return(v)
      end
   end
end

function sendNextOrder(turtle)
   local index
   print("Sending work order " .. turtle.work[1].order)
   sendOrder(turtle, turtle.work[1].order, turtle.work[1].args)
   table.remove(turtle.work, 1)
   if #turtle.work == 0 then
      turtle.work = nil
   end
end
   
function processMessage(sid, msg)
   if msg == "Hello all!" then
      login(sid)
   elseif msg == "Awaiting Orders!" then
      local turtle = getTurtleByID(sid)
      if turtle == nil then
	 turtle = login(sid)
      end
      if turtle.work ~= nil then
	 sendNextOrder(turtle)
      else
	 turtle.status = "waiting"
      end
   else 
      print("Ignoring message " .. msg .. ".")
   end
end

function sendOrder(turtle, order, args)
   
   assert(type(order) == "string")
   assert(type(args) == "table")
   print("Turtle ID " .. tostring(turtle.id))
   rednet.send(turtle.id, order .. " " .. table.concat(args, " "))
   turtle.status = "working"
end


function serv(workList)
   local workRemaining = workList
   print(workRemaining)
   while true do
      sid, msg = rednet.receive(1)
      
      if sid then
	 print("Processing message '" .. msg .. "'\n")
	 processMessage(sid, msg)
      else
	 if turtles[1] and workRemaining then
--	    print("Looking for turtles to do work...")
	    for i,v in pairs(turtles) do
	       if v.status == "waiting" and v.work == nil then
		  print("Dispatching work to turtle" .. i)
		  v.work = workRemaining[1]
		  sendNextOrder(v)
		  if #workRemaining ~= 1 then
		     table.remove(workRemaining, 1)
		  else
		     workRemaining = nil
		     print("All orders dispatched!")
		  end
		  
		  
	       end
	    end
	 end
	-- print("waiting...")
      end
   end
end

assert(#args == 3, "usage: server x y z")
assert(type(args[1]) == "string")
startingPoint = {x = args[1], y = args[2], z = args[3]}
workList = {{{order = "goto", args = {0+startingPoint.x,
				      0+startingPoint.y,
				      0+startingPoint.z}},
	     {order = "face", args = {EAST}},
	     {order = "wall", args = {10,10}},
	     {order = "goto", args = {0, 0, 0}}},
	    {{order = "goto", args = {0+startingPoint.x,
				      10+startingPoint.y,
				      0+startingPoint.z}},
	     {order = "face", args = {NORTH}},
	     {order = "wall", args = {10, 10}},
	     {order = "goto", args = {0, 1, 0}}},
	    {{order = "goto", args = {10+startingPoint.x,
				      10+startingPoint.y,
				      0+startingPoint.z}},
	     {order = "face", args = {WEST}},
	     {order = "wall", args = {10, 10}},
	     {order = "goto", args = {0, 5, 0}}},
	    {{order = "goto", args = {10+startingPoint.x,
				      0+startingPoint.y,
				      0+startingPoint.z}},
	     {order = "face", args = {SOUTH}},
	     {order = "wall", args = {10, 10}},
	     {order = "goto", args = {0, 2, 0}}},
	    {{order = "goto", args = {startingPoint.x + 1,
				      startingPoint.y + 1,
				      10+startingPoint.z}},
	     {order = "face", args = {EAST}},
	     {order = "floor", args = {9, 9}},
	     {order = "goto", args = {0, 3, 0}}},
	    {{order = "goto", args = {1+ startingPoint.x,
				      1+startingPoint.y,
				      1+startingPoint.z}},
	     {order = "face", args = {EAST}},
	     {order = "floor", args = {9, 9}},
	     {order = "goto", args = {0, 4, 0}}}}
	    
	    

rednet.open("back")
serv(workList)